// ADD:
// m = (p_y - q_y) / (p_x - q_x)
// r_x = m^2 - p_x - q_x
// r_y = m * (r_x - p_x) - p_y
// DOUBLE:
// m = (3 * p_x^2) / 2 * p_y
// r_x = m * m - 2 * p_x
// r_y = m * (p_x - r_x) - p_y
// LADDER:
// m_0 = (q_y - p_y) / (q_x - p_x)
// f = m_0 * m_0 - p_x - q_x
// m_1 = m_0 + 2 * p_y / (f - p_x)
// r_x = m_1 * m_1 - p_x - f
// r_y = m_1 * (r_x - p_x) - p_y

use crate::integer::{
	native::{Integer, ReductionWitness},
	rns::RnsParams,
};
use halo2wrong::halo2::arithmetic::{Field, FieldExt};
use num_bigint::BigUint;
use num_traits::{FromPrimitive, Zero};

/// Structure for the EcPoint
#[derive(Clone, Debug)]
pub struct EcPoint<W: FieldExt, N: FieldExt, const NUM_LIMBS: usize, const NUM_BITS: usize, P>
where
	P: RnsParams<W, N, NUM_LIMBS, NUM_BITS>,
{
	/// X coordinate of the EcPoint
	pub x: Integer<W, N, NUM_LIMBS, NUM_BITS, P>,
	/// Y coordinate of the EcPoint
	pub y: Integer<W, N, NUM_LIMBS, NUM_BITS, P>,
	/// Reduction Witnesses for the EcPoint operations
	pub reduction_witnesses: Vec<ReductionWitness<W, N, NUM_LIMBS, NUM_BITS, P>>,
}

impl<W: FieldExt, N: FieldExt, const NUM_LIMBS: usize, const NUM_BITS: usize, P>
	EcPoint<W, N, NUM_LIMBS, NUM_BITS, P>
where
	P: RnsParams<W, N, NUM_LIMBS, NUM_BITS>,
{
	/// Create a new object
	pub fn new(
		x: Integer<W, N, NUM_LIMBS, NUM_BITS, P>, y: Integer<W, N, NUM_LIMBS, NUM_BITS, P>,
	) -> Self {
		Self { x, y, reduction_witnesses: Vec::new() }
	}

	/// Create a new object with x = 0 and y = 1
	pub fn zero() -> Self {
		Self::new(Integer::zero(), Integer::one())
	}

	/// Create a new object with x = 0 and y = 0
	pub fn identity() -> Self {
		Self::new(Integer::zero(), Integer::zero())
	}

	/// Add one point to another
	pub fn add(&self, other: &Self) -> Self {
		// m = (q_y - p_y) / (q_x - p_x)
		let numerator = other.y.sub(&self.y);
		let denominator = other.x.sub(&self.x);
		let m = numerator.result.div(&denominator.result);
		// r_x = m^2 - p_x - q_x
		let m_squared = m.result.mul(&m.result);
		let m_squared_minus_p_x = m_squared.result.sub(&self.x);
		let r_x = m_squared_minus_p_x.result.sub(&other.x);
		// r_y = m * (p_x - r_x) - p_y
		let r_x_minus_p_x = self.x.sub(&r_x.result);
		let m_times_r_x_minus_p_x = m.result.mul(&r_x_minus_p_x.result);
		let r_y = m_times_r_x_minus_p_x.result.sub(&self.y);

		let reduction_witnesses = vec![
			numerator,
			denominator,
			m,
			m_squared,
			m_squared_minus_p_x,
			r_x.clone(),
			r_x_minus_p_x,
			m_times_r_x_minus_p_x,
			r_y.clone(),
		];

		Self { x: r_x.result, y: r_y.result, reduction_witnesses }
	}

	/// Double the given point
	pub fn double(&self) -> Self {
		// m = (3 * p_x^2) / 2 * p_y
		let double_p_y = self.y.add(&self.y);
		let p_x_square = self.x.mul(&self.x);
		let p_x_square_times_two = p_x_square.result.add(&p_x_square.result);
		let p_x_square_times_three = p_x_square.result.add(&p_x_square_times_two.result);
		let m = p_x_square_times_three.result.div(&double_p_y.result);

		// r_x = m * m - 2 * p_x
		let double_p_x = self.x.add(&self.x);
		let m_squared = m.result.mul(&m.result);
		let r_x = m_squared.result.sub(&double_p_x.result);

		// r_y = m * (p_x - r_x) - p_y
		let p_x_minus_r_x = self.x.sub(&r_x.result);
		let m_times_p_x_minus_r_x = m.result.mul(&p_x_minus_r_x.result);
		let r_y = m_times_p_x_minus_r_x.result.sub(&self.y);

		let reduction_witnesses = vec![
			double_p_y,
			p_x_square,
			p_x_square_times_two,
			p_x_square_times_three,
			m,
			double_p_x,
			m_squared,
			r_x.clone(),
			p_x_minus_r_x,
			m_times_p_x_minus_r_x,
			r_y.clone(),
		];

		Self { x: r_x.result, y: r_y.result, reduction_witnesses }
	}

	/// Scalar multiplication for given point
	pub fn mul_scalar(&self, le_bytes: &[u8]) -> Self {
		// TODO: try ::identity()
		let mut r = Self::zero();
		// let exp: EcPoint<W, N, NUM_LIMBS, NUM_BITS, P> = self.clone();

		// Big Endian vs Little Endian
		let bytes = le_bytes.clone();
		let bits: Vec<bool> = bytes
			.iter()
			.rev()
			.map(|byte| {
				let mut byte_bits = [false; 8];
				for i in (0..8).rev() {
					byte_bits[i] = (byte >> i) & 1u8 != 0
				}
				byte_bits
			})
			.flatten()
			.collect();

		// Double and Add operation
		for bit in bits {
			r = r.double();
			if bit {
				r = r.add(&self.clone());
			}
		}
		r
	}

	/// Check if two points are equal
	pub fn is_eq(&self, other: &Self) -> bool {
		self.x.is_eq(&other.x) && self.y.is_eq(&other.y)
	}
}

/// Performs bitwise AND to test bits.
pub fn test_bit(b: &[u8], i: usize) -> bool {
	b[i / 8] & (1 << (i % 8)) != 0
}

#[cfg(test)]
mod test {
	use halo2wrong::{
		curves::{
			bn256::{Bn256, Fq, Fr, G1Affine},
			group::{
				ff::{BitViewSized, PrimeField},
				Curve,
			},
			CurveAffine,
		},
		halo2::arithmetic::Field,
	};
	use num_bigint::BigUint;
	use num_traits::FromPrimitive;
	use rand::thread_rng;

	use crate::integer::{
		native::Integer,
		rns::{big_to_fe, compose_big, fe_to_big, Bn256_4_68, RnsParams},
	};

	use super::EcPoint;

	#[test]
	fn should_add_two_points() {
		let rng = &mut thread_rng();

		let a = G1Affine::random(rng.clone());
		let b = G1Affine::random(rng.clone());
		let c = (a + b).to_affine();

		let a_x_bn = fe_to_big(a.x);
		let a_y_bn = fe_to_big(a.y);
		let b_x_bn = fe_to_big(b.x);
		let b_y_bn = fe_to_big(b.y);

		let a_x_w = Integer::<Fq, Fr, 4, 68, Bn256_4_68>::new(a_x_bn);
		let a_y_w = Integer::<Fq, Fr, 4, 68, Bn256_4_68>::new(a_y_bn);
		let b_x_w = Integer::<Fq, Fr, 4, 68, Bn256_4_68>::new(b_x_bn);
		let b_y_w = Integer::<Fq, Fr, 4, 68, Bn256_4_68>::new(b_y_bn);

		let a_w = EcPoint::new(a_x_w, a_y_w);
		let b_w = EcPoint::new(b_x_w, b_y_w);
		let c_w = a_w.add(&b_w);

		assert_eq!(c.x, big_to_fe(c_w.x.value()));
		assert_eq!(c.y, big_to_fe(c_w.y.value()));
	}

	#[test]
	fn should_double_point() {
		let rng = &mut thread_rng();

		let a = G1Affine::random(rng.clone());
		let c = (a + a).to_affine();

		let a_x_bn = fe_to_big(a.x);
		let a_y_bn = fe_to_big(a.y);

		let a_x_w = Integer::<Fq, Fr, 4, 68, Bn256_4_68>::new(a_x_bn);
		let a_y_w = Integer::<Fq, Fr, 4, 68, Bn256_4_68>::new(a_y_bn);

		let a_w = EcPoint::new(a_x_w, a_y_w);
		let c_w = a_w.double();

		assert_eq!(c.x, big_to_fe(c_w.x.value()));
		assert_eq!(c.y, big_to_fe(c_w.y.value()));
	}

	#[test]
	fn should_mul_scalar() {
		let rng = &mut thread_rng();

		let a = G1Affine::random(rng.clone());
		let scalar = Fr::one();
		let c = (a * scalar).to_affine();

		let a_x_bn = fe_to_big(a.x);
		let a_y_bn = fe_to_big(a.y);

		let a_x_w = Integer::<Fq, Fr, 4, 68, Bn256_4_68>::new(a_x_bn);
		let a_y_w = Integer::<Fq, Fr, 4, 68, Bn256_4_68>::new(a_y_bn);

		let a_w = EcPoint::new(a_x_w, a_y_w);
		let c_w = a_w.mul_scalar(&scalar.to_bytes());

		println!("{:?} {:?}", c.x, big_to_fe::<Fq>(c_w.x.value()));
		// assert_eq!(c.x, big_to_fe(c_w.x.value()));
		// assert_eq!(c.y, big_to_fe(c_w.y.value()));
	}
}
